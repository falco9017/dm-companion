import { getGeminiFlash } from './client'
import { getLanguageLabel } from './audio-processor'
import { getModelWithCachedRecaps } from './cache'
import { prisma } from '@/lib/db'
import { WikiEntryType } from '@prisma/client'
import { trackUsage, extractTokenCounts } from '@/lib/usage-tracking'

interface WikiEntryData {
  title: string
  type: WikiEntryType
  content: string
  excerpt: string
  tags: string[]
}

interface WikiOperation {
  operation: 'CREATE' | 'UPDATE' | 'DELETE'
  slug?: string
  title: string
  type: WikiEntryType
  content: string
  excerpt: string
  tags: string[]
}

export async function generateWikiEntries(
  campaignId: string,
  audioFileId: string,
  transcription: string,
  summary: string,
  language = 'en',
  userId?: string,
  recordingDate?: Date
): Promise<void> {
  try {
    // First, create a session recap entry
    await createSessionRecap(campaignId, audioFileId, summary, transcription, recordingDate)

    // Extract structured entities from the transcript
    const entities = await extractEntities(transcription, language, userId, campaignId)

    // Create wiki entries for each entity
    for (const entity of entities) {
      try {
        await createWikiEntry(campaignId, audioFileId, entity)
      } catch (error) {
        console.error(`Failed to create wiki entry for "${entity.title}":`, error)
      }
    }
  } catch (error) {
    console.error('Wiki generation error:', error)
    throw new Error('Failed to generate wiki entries')
  }
}

export async function createSessionRecap(
  campaignId: string,
  audioFileId: string,
  summary: string,
  transcription: string,
  recordingDate?: Date
): Promise<void> {
  const audioFile = await prisma.audioFile.findUnique({
    where: { id: audioFileId },
  })

  const title = `${audioFile?.filename.replace(/\.(mp3|wav|m4a|ogg)$/i, '')} - Session Recap`
  const slug = await getUniqueSlug(campaignId, title)

  await prisma.wikiEntry.create({
    data: {
      title,
      slug,
      type: 'SESSION_RECAP',
      content: `${summary}\n\n## Full Transcript\n\n${transcription}`,
      excerpt: summary.slice(0, 200),
      tags: ['session', 'recap'],
      isAutoGenerated: true,
      campaignId,
      audioFileId,
      ...(recordingDate ? { createdAt: recordingDate } : {}),
    },
  })
}

async function extractEntities(transcription: string, language = 'en', userId?: string, campaignId?: string): Promise<WikiEntryData[]> {
  const langLabel = getLanguageLabel(language)
  const prompt = `Analyze this tabletop RPG session transcript and extract key entities.

For each significant entity (characters, locations, events, items, NPCs, factions, quests), provide:
1. Title (name of the entity)
2. Type (CHARACTER, LOCATION, EVENT, ITEM, NPC, FACTION, QUEST, LORE, OTHER)
3. Content (detailed description with all relevant information from the transcript)
4. Excerpt (1-2 sentence summary)
5. Tags (3-5 relevant keywords)

IMPORTANT: Write all content, excerpts, and tags in ${langLabel}. Keep entity names in their original form.

Format your response as a JSON array. Only include truly significant entities that warrant their own wiki entries.

Example format:
[
  {
    "title": "Elara Brightblade",
    "type": "CHARACTER",
    "content": "Elara is a human paladin who...",
    "excerpt": "A brave paladin seeking to restore light to the realm.",
    "tags": ["paladin", "protagonist", "holy warrior"]
  }
]

Transcript:
${transcription.slice(0, 20000)}

JSON Array:`

  const result = await getGeminiFlash().generateContent(prompt)

  // Track usage
  if (userId) {
    const tokens = extractTokenCounts(result.response.usageMetadata)
    trackUsage(userId, 'wiki_generation', tokens, campaignId)
  }

  const responseText = result.response.text()

  try {
    // Extract JSON from response (handling markdown code blocks)
    const jsonMatch = responseText.match(/\[[\s\S]*\]/)
    if (!jsonMatch) {
      return []
    }

    const entities = JSON.parse(jsonMatch[0]) as WikiEntryData[]
    return entities.filter((e) => e.title && e.content)
  } catch (error) {
    console.error('Failed to parse wiki entities:', error)
    return []
  }
}

async function createWikiEntry(
  campaignId: string,
  audioFileId: string,
  entity: WikiEntryData
): Promise<'created' | 'updated'> {
  return upsertWikiEntry(campaignId, entity, audioFileId)
}

async function upsertWikiEntry(
  campaignId: string,
  entity: WikiEntryData,
  audioFileId?: string
): Promise<'created' | 'updated'> {
  const slug = generateSlug(entity.title)

  // Check if entry already exists
  const existing = await prisma.wikiEntry.findFirst({
    where: { campaignId, slug },
  })

  if (existing) {
    // Update existing entry with new information
    await prisma.wikiEntry.update({
      where: { id: existing.id },
      data: {
        content: entity.content,
        excerpt: entity.excerpt,
        tags: entity.tags,
        updatedAt: new Date(),
      },
    })
    return 'updated'
  } else {
    // Create new entry
    await prisma.wikiEntry.create({
      data: {
        title: entity.title,
        slug,
        type: entity.type,
        content: entity.content,
        excerpt: entity.excerpt,
        tags: entity.tags,
        isAutoGenerated: true,
        campaignId,
        ...(audioFileId ? { audioFileId } : {}),
      },
    })
    return 'created'
  }
}

export async function generateWikiFromRecaps(
  campaignId: string,
  language: string,
  userInstructions?: string,
  userId?: string
): Promise<{ created: number; updated: number; deleted: number }> {
  const langLabel = getLanguageLabel(language)

  // Fetch all session recaps (strip full transcript to save tokens)
  const recaps = await prisma.wikiEntry.findMany({
    where: { campaignId, type: 'SESSION_RECAP' },
    orderBy: { createdAt: 'asc' },
    select: { title: true, content: true },
  })

  if (recaps.length === 0) {
    throw new Error('No session recaps found. Upload and process audio first.')
  }

  const recapSummaries = recaps.map((r) => {
    // Strip everything after "## Full Transcript" to save context
    const summaryOnly = r.content.split('## Full Transcript')[0].trim()
    return `### ${r.title}\n${summaryOnly}`
  }).join('\n\n')

  // Fetch existing non-recap entries with full content for informed merge decisions
  const existingEntries = await prisma.wikiEntry.findMany({
    where: { campaignId, type: { not: 'SESSION_RECAP' } },
    select: {
      id: true,
      title: true,
      type: true,
      slug: true,
      content: true,
      excerpt: true,
      tags: true,
      isAutoGenerated: true,
      characterSheet: { select: { id: true } },
    },
  })

  const existingList = existingEntries.length > 0
    ? existingEntries.map((e) => {
        const hasSheet = e.characterSheet ? ' [HAS CHARACTER SHEET]' : ''
        const autoGen = e.isAutoGenerated ? '' : ' [USER-CREATED]'
        return `- slug: "${e.slug}" | title: "${e.title}" (${e.type})${hasSheet}${autoGen}\n  excerpt: ${e.excerpt || 'N/A'}\n  content: ${e.content.slice(0, 300)}${e.content.length > 300 ? '...' : ''}`
      }).join('\n')
    : 'None yet.'

  // Get model (with cache if possible)
  const { model, usedCache } = await getModelWithCachedRecaps(campaignId, recapSummaries)

  const instructionsBlock = userInstructions
    ? `\n\nADDITIONAL USER INSTRUCTIONS:\n${userInstructions}`
    : ''

  const recapsSection = usedCache
    ? '(Session recaps are provided via context cache â€” do not ask for them.)'
    : `## Session Recaps\n${recapSummaries}`

  const prompt = `You are a wiki generator for a tabletop RPG campaign. Analyze the session recaps and manage wiki entries using operations.

${recapsSection}

## Existing Wiki Entries
${existingList}

## Instructions
- Return a JSON array of **operations**. Each operation is one of: CREATE, UPDATE, or DELETE.
- **CREATE**: For new entities not yet in the wiki. Provide title, type, content, excerpt, tags.
- **UPDATE**: For existing entries that need changes (new info, corrections, renames). You MUST include the \`slug\` of the existing entry. To rename an entry, use UPDATE with the old slug and the new title.
- **DELETE**: For duplicate or obsolete entries that should be removed. You MUST include the \`slug\` of the entry to delete. Use this to clean up duplicates (keep the better entry via UPDATE, DELETE the duplicate).
- Types: CHARACTER, LOCATION, EVENT, ITEM, NPC, FACTION, QUEST, LORE, OTHER
- NEVER delete SESSION_RECAP entries.
- NEVER delete entries marked [HAS CHARACTER SHEET] or [USER-CREATED].
- When merging duplicates: UPDATE the entry to keep (with combined content) and DELETE the duplicate.
- Write all content, excerpts, and tags in ${langLabel}. Keep entity names in their original form.
- Only include truly significant entities that warrant their own wiki entries.${instructionsBlock}

Return a JSON array:
[
  {
    "operation": "CREATE",
    "title": "New Entity",
    "type": "NPC",
    "content": "Detailed description...",
    "excerpt": "1-2 sentence summary.",
    "tags": ["tag1", "tag2"]
  },
  {
    "operation": "UPDATE",
    "slug": "existing-entity",
    "title": "Updated Name",
    "type": "NPC",
    "content": "Updated description...",
    "excerpt": "Updated summary.",
    "tags": ["tag1", "tag2"]
  },
  {
    "operation": "DELETE",
    "slug": "duplicate-entry",
    "title": "Duplicate Entry",
    "type": "NPC",
    "content": "",
    "excerpt": "",
    "tags": []
  }
]

JSON Array:`

  const result = await model.generateContent(prompt)

  // Track usage
  if (userId) {
    const tokens = extractTokenCounts(result.response.usageMetadata)
    trackUsage(userId, 'wiki_generation', tokens, campaignId, { usedCache })
  }

  const responseText = result.response.text()

  let operations: WikiOperation[] = []
  try {
    const jsonMatch = responseText.match(/\[[\s\S]*\]/)
    if (!jsonMatch) {
      throw new Error('No JSON array found in Gemini response')
    }
    operations = (JSON.parse(jsonMatch[0]) as WikiOperation[]).filter(
      (op) => op.operation && op.title
    )
  } catch (error) {
    console.error('Failed to parse wiki operations from recaps:', error)
    throw new Error('Failed to parse AI response. Please try again.')
  }

  let created = 0
  let updated = 0
  let deleted = 0

  for (const op of operations) {
    try {
      switch (op.operation) {
        case 'CREATE': {
          if (!op.content) break
          await handleCreate(campaignId, op)
          created++
          break
        }
        case 'UPDATE': {
          if (!op.slug || !op.content) break
          const didUpdate = await handleUpdate(campaignId, op)
          if (didUpdate) updated++
          break
        }
        case 'DELETE': {
          if (!op.slug) break
          const didDelete = await handleDelete(campaignId, op.slug)
          if (didDelete) deleted++
          break
        }
      }
    } catch (error) {
      console.error(`Failed to process ${op.operation} for "${op.title}":`, error)
    }
  }

  return { created, updated, deleted }
}

async function handleCreate(
  campaignId: string,
  op: WikiOperation
): Promise<void> {
  const slug = generateSlug(op.title)

  // If an entry with this slug already exists, update it instead
  const existing = await prisma.wikiEntry.findFirst({
    where: { campaignId, slug },
  })

  if (existing) {
    await prisma.wikiEntry.update({
      where: { id: existing.id },
      data: {
        content: op.content,
        excerpt: op.excerpt,
        tags: op.tags,
        updatedAt: new Date(),
      },
    })
  } else {
    await prisma.wikiEntry.create({
      data: {
        title: op.title,
        slug,
        type: op.type,
        content: op.content,
        excerpt: op.excerpt,
        tags: op.tags || [],
        isAutoGenerated: true,
        campaignId,
      },
    })
  }
}

async function handleUpdate(
  campaignId: string,
  op: WikiOperation
): Promise<boolean> {
  const existing = await prisma.wikiEntry.findFirst({
    where: { campaignId, slug: op.slug! },
  })

  if (!existing) return false

  const newSlug = generateSlug(op.title)
  const titleChanged = newSlug !== existing.slug

  // If title changed, check for slug collision
  if (titleChanged) {
    const collision = await prisma.wikiEntry.findFirst({
      where: { campaignId, slug: newSlug, id: { not: existing.id } },
    })
    if (collision) {
      // Merge: update the collision target instead and delete the old entry
      await prisma.wikiEntry.update({
        where: { id: collision.id },
        data: {
          content: op.content,
          excerpt: op.excerpt,
          tags: op.tags || [],
          updatedAt: new Date(),
        },
      })
      // Only delete the old entry if safe
      if (existing.isAutoGenerated) {
        const hasSheet = await prisma.characterSheet.findUnique({
          where: { wikiEntryId: existing.id },
        })
        if (!hasSheet) {
          await prisma.wikiEntry.delete({ where: { id: existing.id } })
        }
      }
      return true
    }
  }

  await prisma.wikiEntry.update({
    where: { id: existing.id },
    data: {
      title: op.title,
      slug: titleChanged ? newSlug : existing.slug,
      type: op.type || existing.type,
      content: op.content,
      excerpt: op.excerpt,
      tags: op.tags || [],
      updatedAt: new Date(),
    },
  })

  return true
}

async function handleDelete(
  campaignId: string,
  slug: string
): Promise<boolean> {
  const entry = await prisma.wikiEntry.findFirst({
    where: { campaignId, slug },
    include: { characterSheet: { select: { id: true } } },
  })

  if (!entry) return false

  // Safety: never delete SESSION_RECAP, user-created, or entries with character sheets
  if (entry.type === 'SESSION_RECAP') return false
  if (!entry.isAutoGenerated) return false
  if (entry.characterSheet) return false

  await prisma.wikiEntry.delete({ where: { id: entry.id } })
  return true
}

function generateSlug(title: string): string {
  return title
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-|-$/g, '')
}

async function getUniqueSlug(campaignId: string, title: string): Promise<string> {
  const base = generateSlug(title)
  let slug = base
  let counter = 1

  while (await prisma.wikiEntry.findFirst({ where: { campaignId, slug } })) {
    slug = `${base}-${counter}`
    counter++
  }

  return slug
}
