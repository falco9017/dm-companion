import { getGeminiFlash } from './client'
import { getLanguageLabel } from './audio-processor'
import { prisma } from '@/lib/db'
import { WikiEntryType } from '@prisma/client'
import { trackUsage, extractTokenCounts } from '@/lib/usage-tracking'

interface WikiEntryData {
  title: string
  type: WikiEntryType
  content: string
  excerpt: string
  tags: string[]
}

export async function generateWikiEntries(
  campaignId: string,
  audioFileId: string,
  transcription: string,
  summary: string,
  language = 'en',
  userId?: string,
  recordingDate?: Date
): Promise<void> {
  try {
    // First, create a session recap entry
    await createSessionRecap(campaignId, audioFileId, summary, transcription, recordingDate)

    // Extract structured entities from the transcript
    const entities = await extractEntities(transcription, language, userId, campaignId)

    // Create wiki entries for each entity
    for (const entity of entities) {
      try {
        await createWikiEntry(campaignId, audioFileId, entity)
      } catch (error) {
        console.error(`Failed to create wiki entry for "${entity.title}":`, error)
      }
    }
  } catch (error) {
    console.error('Wiki generation error:', error)
    throw new Error('Failed to generate wiki entries')
  }
}

async function createSessionRecap(
  campaignId: string,
  audioFileId: string,
  summary: string,
  transcription: string,
  recordingDate?: Date
): Promise<void> {
  const audioFile = await prisma.audioFile.findUnique({
    where: { id: audioFileId },
  })

  const title = `${audioFile?.filename.replace(/\.(mp3|wav|m4a|ogg)$/i, '')} - Session Recap`
  const slug = await getUniqueSlug(campaignId, title)

  await prisma.wikiEntry.create({
    data: {
      title,
      slug,
      type: 'SESSION_RECAP',
      content: `${summary}\n\n## Full Transcript\n\n${transcription}`,
      excerpt: summary.slice(0, 200),
      tags: ['session', 'recap'],
      isAutoGenerated: true,
      campaignId,
      audioFileId,
      ...(recordingDate ? { createdAt: recordingDate } : {}),
    },
  })
}

async function extractEntities(transcription: string, language = 'en', userId?: string, campaignId?: string): Promise<WikiEntryData[]> {
  const langLabel = getLanguageLabel(language)
  const prompt = `Analyze this tabletop RPG session transcript and extract key entities.

For each significant entity (characters, locations, events, items, NPCs, factions, quests), provide:
1. Title (name of the entity)
2. Type (CHARACTER, LOCATION, EVENT, ITEM, NPC, FACTION, QUEST, LORE, OTHER)
3. Content (detailed description with all relevant information from the transcript)
4. Excerpt (1-2 sentence summary)
5. Tags (3-5 relevant keywords)

IMPORTANT: Write all content, excerpts, and tags in ${langLabel}. Keep entity names in their original form.

Format your response as a JSON array. Only include truly significant entities that warrant their own wiki entries.

Example format:
[
  {
    "title": "Elara Brightblade",
    "type": "CHARACTER",
    "content": "Elara is a human paladin who...",
    "excerpt": "A brave paladin seeking to restore light to the realm.",
    "tags": ["paladin", "protagonist", "holy warrior"]
  }
]

Transcript:
${transcription.slice(0, 20000)}

JSON Array:`

  const result = await getGeminiFlash().generateContent(prompt)

  // Track usage
  if (userId) {
    const tokens = extractTokenCounts(result.response.usageMetadata)
    trackUsage(userId, 'wiki_generation', tokens, campaignId)
  }

  const responseText = result.response.text()

  try {
    // Extract JSON from response (handling markdown code blocks)
    const jsonMatch = responseText.match(/\[[\s\S]*\]/)
    if (!jsonMatch) {
      return []
    }

    const entities = JSON.parse(jsonMatch[0]) as WikiEntryData[]
    return entities.filter((e) => e.title && e.content)
  } catch (error) {
    console.error('Failed to parse wiki entities:', error)
    return []
  }
}

async function createWikiEntry(
  campaignId: string,
  audioFileId: string,
  entity: WikiEntryData
): Promise<'created' | 'updated'> {
  return upsertWikiEntry(campaignId, entity, audioFileId)
}

async function upsertWikiEntry(
  campaignId: string,
  entity: WikiEntryData,
  audioFileId?: string
): Promise<'created' | 'updated'> {
  const slug = generateSlug(entity.title)

  // Check if entry already exists
  const existing = await prisma.wikiEntry.findFirst({
    where: { campaignId, slug },
  })

  if (existing) {
    // Update existing entry with new information
    await prisma.wikiEntry.update({
      where: { id: existing.id },
      data: {
        content: entity.content,
        excerpt: entity.excerpt,
        tags: entity.tags,
        updatedAt: new Date(),
      },
    })
    return 'updated'
  } else {
    // Create new entry
    await prisma.wikiEntry.create({
      data: {
        title: entity.title,
        slug,
        type: entity.type,
        content: entity.content,
        excerpt: entity.excerpt,
        tags: entity.tags,
        isAutoGenerated: true,
        campaignId,
        ...(audioFileId ? { audioFileId } : {}),
      },
    })
    return 'created'
  }
}

export async function generateWikiFromRecaps(
  campaignId: string,
  language: string,
  userInstructions?: string,
  userId?: string
): Promise<{ created: number; updated: number }> {
  const langLabel = getLanguageLabel(language)

  // Fetch all session recaps (strip full transcript to save tokens)
  const recaps = await prisma.wikiEntry.findMany({
    where: { campaignId, type: 'SESSION_RECAP' },
    orderBy: { createdAt: 'asc' },
    select: { title: true, content: true },
  })

  if (recaps.length === 0) {
    throw new Error('No session recaps found. Upload and process audio first.')
  }

  const recapSummaries = recaps.map((r) => {
    // Strip everything after "## Full Transcript" to save context
    const summaryOnly = r.content.split('## Full Transcript')[0].trim()
    return `### ${r.title}\n${summaryOnly}`
  }).join('\n\n')

  // Fetch existing non-recap entries for context
  const existingEntries = await prisma.wikiEntry.findMany({
    where: { campaignId, type: { not: 'SESSION_RECAP' } },
    select: { title: true, type: true, slug: true },
  })

  const existingList = existingEntries.length > 0
    ? existingEntries.map((e) => `- ${e.title} (${e.type})`).join('\n')
    : 'None yet.'

  const instructionsBlock = userInstructions
    ? `\n\nADDITIONAL USER INSTRUCTIONS:\n${userInstructions}`
    : ''

  const prompt = `You are a wiki generator for a tabletop RPG campaign. Analyze the following session recaps and generate wiki entries for all significant entities.

## Session Recaps
${recapSummaries}

## Existing Wiki Entries
${existingList}

## Instructions
- For entities that already exist in the wiki, provide UPDATED content that incorporates all information from every session recap.
- For new entities, create comprehensive entries.
- Types: CHARACTER, LOCATION, EVENT, ITEM, NPC, FACTION, QUEST, LORE, OTHER
- Write all content, excerpts, and tags in ${langLabel}. Keep entity names in their original form.
- Only include truly significant entities that warrant their own wiki entries.${instructionsBlock}

Return a JSON array of entities:
[
  {
    "title": "Entity Name",
    "type": "NPC",
    "content": "Detailed description...",
    "excerpt": "1-2 sentence summary.",
    "tags": ["tag1", "tag2", "tag3"]
  }
]

JSON Array:`

  const result = await getGeminiFlash().generateContent(prompt)

  // Track usage
  if (userId) {
    const tokens = extractTokenCounts(result.response.usageMetadata)
    trackUsage(userId, 'wiki_generation', tokens, campaignId)
  }

  const responseText = result.response.text()

  let entities: WikiEntryData[] = []
  try {
    const jsonMatch = responseText.match(/\[[\s\S]*\]/)
    if (!jsonMatch) {
      throw new Error('No JSON array found in Gemini response')
    }
    entities = (JSON.parse(jsonMatch[0]) as WikiEntryData[]).filter((e) => e.title && e.content)
  } catch (error) {
    console.error('Failed to parse wiki entities from recaps:', error)
    throw new Error('Failed to parse AI response. Please try again.')
  }

  let created = 0
  let updated = 0

  for (const entity of entities) {
    try {
      const result = await upsertWikiEntry(campaignId, entity)
      if (result === 'created') created++
      else updated++
    } catch (error) {
      console.error(`Failed to upsert wiki entry "${entity.title}":`, error)
    }
  }

  return { created, updated }
}

function generateSlug(title: string): string {
  return title
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-|-$/g, '')
}

async function getUniqueSlug(campaignId: string, title: string): Promise<string> {
  const base = generateSlug(title)
  let slug = base
  let counter = 1

  while (await prisma.wikiEntry.findFirst({ where: { campaignId, slug } })) {
    slug = `${base}-${counter}`
    counter++
  }

  return slug
}
