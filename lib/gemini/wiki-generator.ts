import { getGeminiFlash } from './client'
import { prisma } from '@/lib/db'
import { WikiEntryType } from '@prisma/client'

interface WikiEntryData {
  title: string
  type: WikiEntryType
  content: string
  excerpt: string
  tags: string[]
}

export async function generateWikiEntries(
  campaignId: string,
  audioFileId: string,
  transcription: string,
  summary: string
): Promise<void> {
  try {
    // First, create a session recap entry
    await createSessionRecap(campaignId, audioFileId, summary, transcription)

    // Extract structured entities from the transcript
    const entities = await extractEntities(transcription)

    // Create wiki entries for each entity
    for (const entity of entities) {
      await createWikiEntry(campaignId, audioFileId, entity)
    }
  } catch (error) {
    console.error('Wiki generation error:', error)
    throw new Error('Failed to generate wiki entries')
  }
}

async function createSessionRecap(
  campaignId: string,
  audioFileId: string,
  summary: string,
  transcription: string
): Promise<void> {
  const audioFile = await prisma.audioFile.findUnique({
    where: { id: audioFileId },
  })

  const title = `${audioFile?.filename.replace(/\.(mp3|wav|m4a|ogg)$/i, '')} - Session Recap`
  const slug = generateSlug(title)

  await prisma.wikiEntry.create({
    data: {
      title,
      slug,
      type: 'SESSION_RECAP',
      content: `${summary}\n\n## Full Transcript\n\n${transcription}`,
      excerpt: summary.slice(0, 200),
      tags: ['session', 'recap'],
      isAutoGenerated: true,
      campaignId,
      audioFileId,
    },
  })
}

async function extractEntities(transcription: string): Promise<WikiEntryData[]> {
  const prompt = `Analyze this tabletop RPG session transcript and extract key entities.

For each significant entity (characters, locations, events, items, NPCs, factions, quests), provide:
1. Title (name of the entity)
2. Type (CHARACTER, LOCATION, EVENT, ITEM, NPC, FACTION, QUEST, LORE, OTHER)
3. Content (detailed description with all relevant information from the transcript)
4. Excerpt (1-2 sentence summary)
5. Tags (3-5 relevant keywords)

Format your response as a JSON array. Only include truly significant entities that warrant their own wiki entries.

Example format:
[
  {
    "title": "Elara Brightblade",
    "type": "CHARACTER",
    "content": "Elara is a human paladin who...",
    "excerpt": "A brave paladin seeking to restore light to the realm.",
    "tags": ["paladin", "protagonist", "holy warrior"]
  }
]

Transcript:
${transcription.slice(0, 20000)}

JSON Array:`

  const result = await getGeminiFlash().generateContent(prompt)
  const responseText = result.response.text()

  try {
    // Extract JSON from response (handling markdown code blocks)
    const jsonMatch = responseText.match(/\[[\s\S]*\]/)
    if (!jsonMatch) {
      return []
    }

    const entities = JSON.parse(jsonMatch[0]) as WikiEntryData[]
    return entities.filter((e) => e.title && e.content)
  } catch (error) {
    console.error('Failed to parse wiki entities:', error)
    return []
  }
}

async function createWikiEntry(
  campaignId: string,
  audioFileId: string,
  entity: WikiEntryData
): Promise<void> {
  const slug = generateSlug(entity.title)

  // Check if entry already exists
  const existing = await prisma.wikiEntry.findFirst({
    where: { campaignId, slug },
  })

  if (existing) {
    // Update existing entry with new information
    await prisma.wikiEntry.update({
      where: { id: existing.id },
      data: {
        content: `${existing.content}\n\n---\n\n${entity.content}`,
        updatedAt: new Date(),
      },
    })
  } else {
    // Create new entry
    await prisma.wikiEntry.create({
      data: {
        title: entity.title,
        slug,
        type: entity.type,
        content: entity.content,
        excerpt: entity.excerpt,
        tags: entity.tags,
        isAutoGenerated: true,
        campaignId,
        audioFileId,
      },
    })
  }
}

function generateSlug(title: string): string {
  return title
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-|-$/g, '')
}
