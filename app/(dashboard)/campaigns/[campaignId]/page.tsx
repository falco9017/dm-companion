import { auth } from '@/lib/auth'
import { getCampaign, getCampaigns } from '@/actions/campaigns'
import { getWikiTree, getWikiEntry } from '@/actions/wiki'
import { getUserProfile } from '@/actions/profile'
import { getEffectiveTier, getLimits } from '@/lib/subscription'
import { notFound } from 'next/navigation'
import WikiPageLayout from '@/components/wiki/WikiPageLayout'

export default async function CampaignPage({
  params,
  searchParams,
}: {
  params: Promise<{ campaignId: string }>
  searchParams: Promise<{ entry?: string }>
}) {
  const { campaignId } = await params
  const { entry: entryParam } = await searchParams
  const session = await auth()
  const userId = session!.user.id

  const [campaign, wikiTree, profile, tier, allCampaigns] = await Promise.all([
    getCampaign(campaignId, userId),
    getWikiTree(campaignId, userId),
    getUserProfile(userId),
    getEffectiveTier(userId),
    getCampaigns(userId),
  ])

  const limits = getLimits(tier)
  const isLocked = limits.maxCampaigns !== Infinity && allCampaigns.length > limits.maxCampaigns

  if (!campaign) {
    notFound()
  }

  // Determine which entry to show
  let activeEntry = null
  let activeEntryId = entryParam

  if (!activeEntryId && wikiTree.length > 0) {
    // Default to latest SESSION_RECAP, or first entry
    const sessionRecap = wikiTree.find((e) => e.type === 'SESSION_RECAP')
    activeEntryId = sessionRecap?.id || wikiTree[0].id
  }

  if (activeEntryId) {
    try {
      activeEntry = await getWikiEntry(activeEntryId, userId)
    } catch {
      // Entry not found, show empty state
    }
  }

  return (
    <WikiPageLayout
      campaignId={campaignId}
      userId={userId}
      campaign={{
        name: campaign.name,
        description: campaign.description,
        language: campaign.language,
      }}
      wikiTree={wikiTree}
      isLocked={isLocked}
      activeEntry={
        activeEntry
          ? {
              id: activeEntry.id,
              title: activeEntry.title,
              type: activeEntry.type,
              content: activeEntry.content,
              tags: activeEntry.tags,
              isAutoGenerated: activeEntry.isAutoGenerated,
              audioFile: activeEntry.audioFile,
              children: activeEntry.children.map((c) => ({
                id: c.id,
                title: c.title,
                excerpt: c.excerpt,
              })),
              createdAt: activeEntry.createdAt,
              updatedAt: activeEntry.updatedAt,
              characterSheet: activeEntry.characterSheet
                ? {
                    id: activeEntry.characterSheet.id,
                    data: activeEntry.characterSheet.data as unknown as import('@/types/character-sheet').CharacterSheetData,
                    pdfBlobUrl: activeEntry.characterSheet.pdfBlobUrl,
                  }
                : null,
            }
          : null
      }
      dateFormat={profile.dateFormat}
    />
  )
}
