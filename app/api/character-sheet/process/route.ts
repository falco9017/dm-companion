import { NextRequest, NextResponse } from 'next/server'
import { auth } from '@/lib/auth'
import { prisma } from '@/lib/db'
import { put, del } from '@vercel/blob'
import { parseCharacterPdf } from '@/lib/gemini/character-parser'

const MAX_SIZE = 10 * 1024 * 1024 // 10MB

export async function POST(request: NextRequest) {
  try {
    const session = await auth()
    if (!session) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const formData = await request.formData()
    const file = formData.get('file') as File | null
    const campaignId = formData.get('campaignId') as string
    const wikiEntryId = formData.get('wikiEntryId') as string | null

    if (!file || !campaignId) {
      return NextResponse.json({ error: 'Missing file or campaignId' }, { status: 400 })
    }

    if (file.size > MAX_SIZE) {
      return NextResponse.json({ error: 'File too large. Maximum 10MB.' }, { status: 400 })
    }

    if (file.type !== 'application/pdf') {
      return NextResponse.json({ error: 'Only PDF files are accepted' }, { status: 400 })
    }

    // Verify campaign ownership
    const campaign = await prisma.campaign.findFirst({
      where: { id: campaignId, ownerId: session.user.id },
    })

    if (!campaign) {
      return NextResponse.json({ error: 'Campaign not found or unauthorized' }, { status: 403 })
    }

    // If wikiEntryId provided, verify it exists and is a CHARACTER type
    if (wikiEntryId) {
      const entry = await prisma.wikiEntry.findUnique({
        where: { id: wikiEntryId },
        select: { type: true, campaignId: true, characterSheet: { select: { id: true } } },
      })
      if (!entry || entry.campaignId !== campaignId) {
        return NextResponse.json({ error: 'Wiki entry not found' }, { status: 404 })
      }
      if (entry.characterSheet) {
        return NextResponse.json({ error: 'Character sheet already exists for this entry' }, { status: 409 })
      }
    }

    // Upload PDF to Vercel Blob
    const timestamp = Date.now()
    const blobPathname = `${campaignId}/character-sheets/${timestamp}-${file.name}`
    const blob = await put(blobPathname, file, { access: 'public' })

    // Read file as base64 for Gemini
    const arrayBuffer = await file.arrayBuffer()
    const base64 = Buffer.from(arrayBuffer).toString('base64')

    // Parse PDF with Gemini
    const characterData = await parseCharacterPdf(base64, 'application/pdf', session.user.id, campaignId)

    // Create or use existing wiki entry
    let entryId = wikiEntryId
    if (!entryId) {
      // Create a new CHARACTER wiki entry
      const slug = characterData.characterName
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/^-|-$/g, '') || `character-${timestamp}`

      // Ensure unique slug
      let uniqueSlug = slug
      let counter = 1
      while (await prisma.wikiEntry.findUnique({ where: { campaignId_slug: { campaignId, slug: uniqueSlug } } })) {
        uniqueSlug = `${slug}-${counter++}`
      }

      const entry = await prisma.wikiEntry.create({
        data: {
          title: characterData.characterName || file.name.replace('.pdf', ''),
          slug: uniqueSlug,
          type: 'CHARACTER',
          content: `${characterData.race} ${characterData.class} (Level ${characterData.level})\n\nBackground: ${characterData.background}\nAlignment: ${characterData.alignment}\n\nImported from PDF.`,
          excerpt: `${characterData.race} ${characterData.class}, Level ${characterData.level}`,
          tags: [characterData.class.toLowerCase(), characterData.race.toLowerCase(), 'player-character'].filter(Boolean),
          isAutoGenerated: true,
          campaignId,
        },
      })
      entryId = entry.id
    }

    // Create character sheet record
    const characterSheet = await prisma.characterSheet.create({
      data: {
        wikiEntryId: entryId,
        campaignId,
        data: JSON.parse(JSON.stringify(characterData)),
        pdfBlobUrl: blob.url,
        pdfBlobKey: blob.pathname,
      },
    })

    // Delete PDF blob to save storage (data is already parsed)
    try {
      await del(blob.url)
      await prisma.characterSheet.update({
        where: { id: characterSheet.id },
        data: { pdfBlobUrl: null, pdfBlobKey: null },
      })
    } catch (blobError) {
      console.error('Failed to delete PDF blob (non-fatal):', blobError)
    }

    return NextResponse.json({
      characterSheetId: characterSheet.id,
      wikiEntryId: entryId,
      characterName: characterData.characterName,
    })
  } catch (error) {
    console.error('Character sheet processing error:', error)
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Processing failed' },
      { status: 500 }
    )
  }
}
