'use server'

import { revalidatePath } from 'next/cache'
import { prisma } from '@/lib/db'
import { WikiEntryType } from '@prisma/client'
import { getCampaignAccess, isDM } from '@/lib/permissions'
import { getGeminiFlash } from '@/lib/gemini/client'

export async function updateSessionRecapDate(entryId: string, userId: string, date: string) {
  const entry = await prisma.wikiEntry.findUnique({
    where: { id: entryId },
    include: { campaign: { select: { id: true } } },
  })

  if (!entry) {
    throw new Error('Wiki entry not found or unauthorized')
  }

  const access = await getCampaignAccess(entry.campaign.id, userId)
  if (!access || !isDM(access)) {
    throw new Error('Wiki entry not found or unauthorized')
  }

  const sessionDate = new Date(date + 'T12:00:00Z')
  await prisma.wikiEntry.update({
    where: { id: entryId },
    data: { createdAt: sessionDate },
  })

  revalidatePath(`/campaigns/${entry.campaign.id}`)
}

export async function updateSessionRecapContent(entryId: string, userId: string, content: string) {
  const entry = await prisma.wikiEntry.findUnique({
    where: { id: entryId },
    include: { campaign: { select: { id: true } } },
  })

  if (!entry) {
    throw new Error('Wiki entry not found or unauthorized')
  }

  const access = await getCampaignAccess(entry.campaign.id, userId)
  if (!access || !isDM(access)) {
    throw new Error('Wiki entry not found or unauthorized')
  }

  await prisma.wikiEntry.update({
    where: { id: entryId },
    data: {
      content,
      excerpt: content.slice(0, 200),
    },
  })

  revalidatePath(`/campaigns/${entry.campaign.id}`)
}

export async function reviseRecap(currentText: string, instruction: string): Promise<string> {
  const model = getGeminiFlash()
  const prompt = `You are editing a tabletop RPG session recap. Apply the following revision instruction to the recap text.

REVISION INSTRUCTION: ${instruction}

CURRENT RECAP TEXT:
${currentText}

Return ONLY the revised recap text with no additional commentary, explanations, or formatting markers. Preserve the general structure and markdown formatting of the original text.`

  const result = await model.generateContent(prompt)
  return result.response.text().trim()
}

export async function createSessionEntry(
  campaignId: string,
  userId: string,
  date: string,
  title?: string
) {
  const access = await getCampaignAccess(campaignId, userId)
  if (!access || !isDM(access)) {
    throw new Error('Campaign not found or unauthorized')
  }

  // Parse the date for createdAt
  const sessionDate = new Date(date + 'T12:00:00Z')

  // Format date for default title (DD.MM.YY)
  const day = String(sessionDate.getUTCDate()).padStart(2, '0')
  const month = String(sessionDate.getUTCMonth() + 1).padStart(2, '0')
  const year = String(sessionDate.getUTCFullYear()).slice(-2)
  const dateStr = `${day}.${month}.${year}`

  const sessionTitle = title || `Session - ${dateStr}`

  const baseSlug = slugify(sessionTitle)
  let slug = baseSlug
  let counter = 1
  while (await prisma.wikiEntry.findUnique({ where: { campaignId_slug: { campaignId, slug } } })) {
    slug = `${baseSlug}-${counter++}`
  }

  const entry = await prisma.wikiEntry.create({
    data: {
      title: sessionTitle,
      slug,
      type: 'SESSION_RECAP',
      content: '',
      excerpt: '',
      tags: [],
      isAutoGenerated: false,
      campaignId,
      createdAt: sessionDate,
    },
  })

  revalidatePath(`/campaigns/${campaignId}`)
  return entry
}

function slugify(text: string): string {
  return text
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '')
}

export async function createWikiEntry(
  campaignId: string,
  userId: string,
  data: {
    title: string
    type: WikiEntryType
    content: string
    excerpt?: string
    tags?: string[]
  }
) {
  const access = await getCampaignAccess(campaignId, userId)
  if (!access || !isDM(access)) {
    throw new Error('Campaign not found or unauthorized')
  }

  const baseSlug = slugify(data.title)
  let slug = baseSlug
  let counter = 1

  // Ensure unique slug
  while (await prisma.wikiEntry.findUnique({ where: { campaignId_slug: { campaignId, slug } } })) {
    slug = `${baseSlug}-${counter++}`
  }

  const entry = await prisma.wikiEntry.create({
    data: {
      title: data.title,
      slug,
      type: data.type,
      content: data.content,
      excerpt: data.excerpt || data.content.slice(0, 200),
      tags: data.tags || [],
      isAutoGenerated: false,
      campaignId,
    },
  })

  revalidatePath(`/campaigns/${campaignId}/wiki`)
  return entry
}

export async function getWikiEntries(
  campaignId: string,
  userId: string,
  filters?: {
    type?: WikiEntryType
    search?: string
    tags?: string[]
  }
) {
  const access = await getCampaignAccess(campaignId, userId)
  if (!access || !isDM(access)) {
    throw new Error('Campaign not found or unauthorized')
  }

  const where: Record<string, unknown> = { campaignId }

  if (filters?.type) {
    where.type = filters.type
  }

  if (filters?.search) {
    where.OR = [
      { title: { contains: filters.search, mode: 'insensitive' } },
      { content: { contains: filters.search, mode: 'insensitive' } },
      { excerpt: { contains: filters.search, mode: 'insensitive' } },
    ]
  }

  if (filters?.tags && filters.tags.length > 0) {
    where.tags = { hasSome: filters.tags }
  }

  return await prisma.wikiEntry.findMany({
    where,
    orderBy: { createdAt: 'desc' },
    include: {
      audioFile: {
        select: {
          id: true,
          filename: true,
        },
      },
    },
  })
}

export async function getWikiEntry(entryId: string, userId: string) {
  const entry = await prisma.wikiEntry.findUnique({
    where: { id: entryId },
    include: {
      campaign: true,
      audioFile: {
        select: {
          id: true,
          filename: true,
        },
      },
      children: true,
      characterSheet: {
        select: {
          id: true,
          data: true,
          pdfBlobUrl: true,
          assignedPlayerId: true,
        },
      },
    },
  })

  if (!entry) {
    throw new Error('Wiki entry not found or unauthorized')
  }

  const access = await getCampaignAccess(entry.campaign.id, userId)
  if (!access) {
    throw new Error('Wiki entry not found or unauthorized')
  }

  // Players can only access their own assigned CHARACTER entry
  if (!isDM(access)) {
    const isOwnCharacter =
      entry.type === 'CHARACTER' &&
      entry.characterSheet?.assignedPlayerId === userId
    if (!isOwnCharacter) {
      throw new Error('Wiki entry not found or unauthorized')
    }
  }

  return entry
}

export async function searchWikiEntries(
  campaignId: string,
  userId: string,
  query: string
) {
  const access = await getCampaignAccess(campaignId, userId)
  if (!access || !isDM(access)) {
    throw new Error('Campaign not found or unauthorized')
  }

  return await prisma.wikiEntry.findMany({
    where: {
      campaignId,
      OR: [
        { title: { contains: query, mode: 'insensitive' } },
        { content: { contains: query, mode: 'insensitive' } },
        { excerpt: { contains: query, mode: 'insensitive' } },
        { tags: { has: query.toLowerCase() } },
      ],
    },
    orderBy: { createdAt: 'desc' },
    take: 20,
  })
}

export async function updateWikiEntry(
  entryId: string,
  userId: string,
  data: {
    title?: string
    content?: string
    type?: WikiEntryType
    tags?: string[]
  }
) {
  const entry = await prisma.wikiEntry.findUnique({
    where: { id: entryId },
    include: { campaign: { select: { ownerId: true, id: true } } },
  })

  if (!entry) {
    throw new Error('Wiki entry not found or unauthorized')
  }

  const access = await getCampaignAccess(entry.campaign.id, userId)
  if (!access || !isDM(access)) {
    throw new Error('Wiki entry not found or unauthorized')
  }

  const updated = await prisma.wikiEntry.update({
    where: { id: entryId },
    data: {
      ...(data.title !== undefined && { title: data.title }),
      ...(data.content !== undefined && { content: data.content, excerpt: data.content.slice(0, 200) }),
      ...(data.type !== undefined && { type: data.type }),
      ...(data.tags !== undefined && { tags: data.tags }),
    },
  })

  revalidatePath(`/campaigns/${entry.campaign.id}`)
  return updated
}

export async function deleteWikiEntry(entryId: string, userId: string) {
  const entry = await prisma.wikiEntry.findUnique({
    where: { id: entryId },
    include: { campaign: { select: { ownerId: true, id: true } } },
  })

  if (!entry) {
    throw new Error('Wiki entry not found or unauthorized')
  }

  const access = await getCampaignAccess(entry.campaign.id, userId)
  if (!access || !isDM(access)) {
    throw new Error('Wiki entry not found or unauthorized')
  }

  await prisma.wikiEntry.delete({ where: { id: entryId } })

  revalidatePath(`/campaigns/${entry.campaign.id}`)
}

export async function getWikiTree(campaignId: string, userId: string) {
  const access = await getCampaignAccess(campaignId, userId)
  if (!access || !isDM(access)) {
    throw new Error('Campaign not found or unauthorized')
  }

  return await prisma.wikiEntry.findMany({
    where: { campaignId },
    select: {
      id: true,
      title: true,
      slug: true,
      type: true,
      parentId: true,
      createdAt: true,
    },
    orderBy: [{ type: 'asc' }, { createdAt: 'desc' }],
  })
}

export async function getWikiEntriesByType(
  campaignId: string,
  userId: string
) {
  const access = await getCampaignAccess(campaignId, userId)
  if (!access || !isDM(access)) {
    throw new Error('Campaign not found or unauthorized')
  }

  const entries = await prisma.wikiEntry.groupBy({
    by: ['type'],
    where: { campaignId },
    _count: true,
  })

  return entries
}
